import * as tslib_1 from "tslib";
import * as React from 'react';
import { autobind } from '@shopify/javascript-utilities/decorators';
import { createUniqueIDFactory } from '@shopify/javascript-utilities/other';
import { classNames } from '@shopify/react-utilities/styles';
import Labelled, { helpTextID, labelID } from '../Labelled';
import Connected from '../Connected';
import { Key } from '../../types';
import { Resizer, Spinner } from './components';
import * as styles from './TextField.scss';
const getUniqueID = createUniqueIDFactory('TextField');
export default class TextField extends React.PureComponent {
    constructor(props) {
        super(props);
        this.state = {
            height: null,
            focus: false,
            id: props.id || getUniqueID(),
        };
    }
    static getDerivedStateFromProps(nextProps, prevState) {
        return { id: nextProps.id || prevState.id };
    }
    componentDidUpdate({ focused }) {
        if (this.input &&
            focused !== this.props.focused &&
            this.props.focused === true) {
            this.input.focus();
        }
    }
    render() {
        const { id = this.state.id, value = '', placeholder, disabled, readOnly, role, autoFocus, type, name, error, multiline, connectedRight, connectedLeft, label, labelAction, labelHidden, helpText, prefix, suffix, onFocus, onBlur, autoComplete, min, max, step, minLength, maxLength, spellCheck, pattern, ariaOwns, ariaActiveDescendant, ariaAutocomplete, ariaControls, } = this.props;
        const { height } = this.state;
        const className = classNames(styles.TextField, Boolean(value) && styles.hasValue, disabled && styles.disabled, readOnly && styles.readOnly, error && styles.error, multiline && styles.multiline, this.state.focus && styles.focus);
        const inputType = type === 'currency' ? 'text' : type;
        const prefixMarkup = prefix ? (<div className={styles.Prefix} id={`${id}Prefix`}>
        {prefix}
      </div>) : null;
        const suffixMarkup = suffix ? (<div className={styles.Suffix} id={`${id}Suffix`}>
        {suffix}
      </div>) : null;
        const spinnerMarkup = type === 'number' && !disabled ? (<Spinner onChange={this.handleNumberChange} onMouseDown={this.handleButtonPress} onMouseUp={this.handleButtonRelease}/>) : null;
        const style = multiline && height ? { height } : null;
        const resizer = multiline ? (<Resizer contents={value || placeholder} currentHeight={height} minimumLines={typeof multiline === 'number' ? multiline : 1} onHeightChange={this.handleExpandingResize}/>) : null;
        const describedBy = [];
        if (error) {
            describedBy.push(`${id}Error`);
        }
        if (helpText) {
            describedBy.push(helpTextID(id));
        }
        const labelledBy = [labelID(id)];
        if (prefix) {
            labelledBy.push(`${id}Prefix`);
        }
        if (suffix) {
            labelledBy.push(`${id}Suffix`);
        }
        const inputClassName = classNames(styles.Input, suffix && styles['Input-suffixed']);
        const input = React.createElement(multiline ? 'textarea' : 'input', {
            name,
            id,
            disabled,
            readOnly,
            role,
            autoFocus,
            value,
            placeholder,
            onFocus,
            onBlur,
            onKeyPress: this.handleKeyPress,
            style,
            autoComplete: normalizeAutoComplete(autoComplete),
            className: inputClassName,
            onChange: this.handleChange,
            ref: this.setInput,
            min,
            max,
            step,
            minLength,
            maxLength,
            spellCheck,
            pattern,
            type: inputType,
            'aria-describedby': describedBy.length
                ? describedBy.join(' ')
                : undefined,
            'aria-label': label,
            'aria-labelledby': labelledBy.join(' '),
            'aria-invalid': Boolean(error),
            'aria-owns': ariaOwns,
            'aria-activedescendant': ariaActiveDescendant,
            'aria-autocomplete': ariaAutocomplete,
            'aria-controls': ariaControls,
            'aria-multiline': multiline,
        });
        return (<Labelled label={label} id={id} error={error} action={labelAction} labelHidden={labelHidden} helpText={helpText}>
        <Connected left={connectedLeft} right={connectedRight}>
          <div className={className} onFocus={this.handleFocus} onBlur={this.handleBlur} onClick={this.handleClick}>
            {prefixMarkup}
            {input}
            {suffixMarkup}
            {spinnerMarkup}
            <div className={styles.Backdrop}/>
            {resizer}
          </div>
        </Connected>
      </Labelled>);
    }
    setInput(input) {
        this.input = input;
    }
    handleNumberChange(steps) {
        const { onChange, value, step = 1, min = -Infinity, max = Infinity, } = this.props;
        if (onChange == null) {
            return;
        }
        // Returns the length of decimal places in a number
        const dpl = (num) => (num.toString().split('.')[1] || []).length;
        const numericValue = value ? parseFloat(value) : 0;
        if (isNaN(numericValue)) {
            return;
        }
        // Making sure the new value has the same length of decimal places as the
        // step / value has.
        const decimalPlaces = Math.max(dpl(numericValue), dpl(step));
        const newValue = Math.min(max, Math.max(numericValue + steps * step, min));
        onChange(String(newValue.toFixed(decimalPlaces)), this.state.id);
    }
    handleExpandingResize(height) {
        this.setState({ height });
    }
    handleKeyPress(event) {
        const { key, which } = event;
        const { type } = this.props;
        const numbersSpec = /[\d.eE+-]$/;
        if (type !== 'number' || which === Key.Enter || key.match(numbersSpec)) {
            return;
        }
        event.preventDefault();
    }
    handleChange(event) {
        const { onChange } = this.props;
        if (onChange == null) {
            return;
        }
        onChange(event.currentTarget.value, this.state.id);
    }
    handleFocus() {
        this.setState({ focus: true });
    }
    handleBlur() {
        this.setState({ focus: false });
    }
    handleClick() {
        this.input.focus();
    }
    handleButtonPress(onChange) {
        const minInterval = 50;
        const decrementBy = 10;
        let interval = 200;
        const onChangeInterval = () => {
            if (interval > minInterval)
                interval -= decrementBy;
            onChange();
            this.buttonPressTimer = window.setTimeout(onChangeInterval, interval);
        };
        this.buttonPressTimer = window.setTimeout(onChangeInterval, interval);
    }
    handleButtonRelease() {
        clearTimeout(this.buttonPressTimer);
    }
}
tslib_1.__decorate([
    autobind
], TextField.prototype, "setInput", null);
tslib_1.__decorate([
    autobind
], TextField.prototype, "handleNumberChange", null);
tslib_1.__decorate([
    autobind
], TextField.prototype, "handleExpandingResize", null);
tslib_1.__decorate([
    autobind
], TextField.prototype, "handleKeyPress", null);
tslib_1.__decorate([
    autobind
], TextField.prototype, "handleChange", null);
tslib_1.__decorate([
    autobind
], TextField.prototype, "handleFocus", null);
tslib_1.__decorate([
    autobind
], TextField.prototype, "handleBlur", null);
tslib_1.__decorate([
    autobind
], TextField.prototype, "handleClick", null);
tslib_1.__decorate([
    autobind
], TextField.prototype, "handleButtonPress", null);
tslib_1.__decorate([
    autobind
], TextField.prototype, "handleButtonRelease", null);
function normalizeAutoComplete(autoComplete) {
    if (autoComplete == null) {
        return autoComplete;
    }
    return autoComplete ? 'on' : 'off';
}
