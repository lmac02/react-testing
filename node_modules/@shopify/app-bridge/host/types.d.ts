/**
 * @module host
 */
import { AnyAction, Dispatch, Unsubscribe } from '../actions/types';
export declare const MessageTransportType = "application";
export declare type Handler = (event: {
    data: AnyAction;
}) => void;
export interface MessageTransport {
    localOrigin: string;
    hostFrame: Window;
    dispatch(message: any): void;
    subscribe(handler: Handler): () => void;
}
/**
 * Configuration provided by an app.
 */
export interface AppConfig {
    apiKey: string;
}
/**
 * Configuration for an app.
 */
export interface PrivilegedAppConfig extends AppConfig {
    apiClientId: string;
    appId: string;
    name: string;
    shopId: string;
    url: string;
}
export declare type ApiClientConfig = PrivilegedAppConfig;
/**
 * Interface for interacting with a loaded application. An application may have
 * many transports for communication (e.g. multiple frames).
 */
export interface Application {
    /**
     * Attach a transport to an application.
     */
    attach(to: MessageTransport): () => void;
    /**
     * Dispatch an action on all transports for an application.
     *
     * @todo Add option to dispatch directly to a given transport
     */
    dispatch(action: AnyAction): void;
    /**
     * Get the current state of an application.
     *
     * @todo Filter once application state structure is finalised
     */
    getState(): any;
    /**
     * Subscribe to all actions from an application on all transports.
     */
    subscribe(listener: () => void): () => void;
}
export interface LoadData {
    type: typeof MessageTransportType;
    config: ApiClientConfig;
}
export interface MiddlewareAPI<S> {
    dispatch: Dispatch<S>;
    getState(): S;
}
/**
 * Build middleware, binding it to a given Redux Store. The returned middleware
 * will be responsible for loading application instances.
 */
export interface Middleware {
    load(data: LoadData): Application;
    <S>(api: MiddlewareAPI<S>): (next: Dispatch<S>) => Dispatch<S>;
}
export declare type Reducer<S> = (state: S, action: AnyAction) => S;
export interface Store<S> {
    dispatch: Dispatch<S>;
    getState(): S;
    subscribe(listener: () => void): Unsubscribe;
    replaceReducer(nextReducer: Reducer<S>): void;
}
export { AnyAction, Dispatch };
