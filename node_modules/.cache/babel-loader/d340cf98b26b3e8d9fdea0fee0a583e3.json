{"ast":null,"code":"'use strict';\n/**\n * Class representing a token bucket.\n */\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\fusi0\\\\OneDrive\\\\Documents\\\\nodejs-test\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\fusi0\\\\OneDrive\\\\Documents\\\\nodejs-test\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar TokenBucket =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Create a new `TokenBucket`.\n   *\n   * @param {Object} options Options object\n   * @param {Number} options.limit The tokens to add per `interval`\n   * @param {Number} options.interval The interval at which tokens are added\n   * @param {Number} options.bucketSize The capacity of the bucket\n   */\n  function TokenBucket(options) {\n    _classCallCheck(this, TokenBucket);\n\n    this.tokens = this.capacity = options.bucketSize;\n    this.interval = options.interval;\n    this.limit = options.limit;\n    this.last = Date.now();\n  }\n  /**\n   * Refill the bucket with a proper amount of tokens.\n   */\n\n\n  _createClass(TokenBucket, [{\n    key: \"refill\",\n    value: function refill() {\n      var now = Date.now();\n      var tokens = Math.floor((now - this.last) * this.limit / this.interval);\n      this.tokens += tokens; //\n      // `tokens` is rounded downward, so we only add the actual time required by\n      // those tokens.\n      //\n\n      this.last += Math.ceil(tokens * this.interval / this.limit);\n\n      if (this.tokens > this.capacity) {\n        this.tokens = this.capacity;\n        this.last = now;\n      }\n    }\n    /**\n     * Remove a token from the bucket.\n     *\n     * @return {Number} The amount of time to wait for a token to be available\n     */\n\n  }, {\n    key: \"consume\",\n    value: function consume() {\n      this.refill();\n\n      if (this.tokens) {\n        this.tokens--;\n        return 0;\n      }\n\n      return Math.ceil(this.interval / this.limit - (Date.now() - this.last));\n    }\n  }]);\n\n  return TokenBucket;\n}();\n/**\n * Limit the execution rate of a function using a leaky bucket algorithm.\n *\n * @param {Function} fn The function to rate limit calls to\n * @param {Object} options Options object\n * @param {Number} options.limit The number of allowed calls per `interval`\n * @param {Number} options.interval The timespan where `limit` is calculated\n * @param {Number} options.queueSize The maximum size of the queue\n * @param {Number} options.bucketSize The capacity of the bucket\n * @return {Function}\n * @public\n */\n\n\nfunction stopcock(fn, options) {\n  options = Object.assign({\n    queueSize: Math.pow(2, 32) - 1,\n    bucketSize: 40,\n    interval: 1000,\n    limit: 2\n  }, options);\n  var bucket = new TokenBucket(options);\n  var queue = [];\n  var timer = null;\n\n  function shift() {\n    clearTimeout(timer);\n\n    while (queue.length) {\n      var delay = bucket.consume();\n\n      if (delay > 0) {\n        timer = setTimeout(shift, delay);\n        break;\n      }\n\n      var data = queue.shift();\n      data[2](fn.apply(data[0], data[1]));\n    }\n  }\n\n  return function limiter() {\n    var _this = this;\n\n    var args = arguments;\n    return new Promise(function (resolve, reject) {\n      if (queue.length === options.queueSize) {\n        return reject(new Error('Queue is full'));\n      }\n\n      queue.push([_this, args, resolve]);\n      shift();\n    });\n  };\n}\n\nmodule.exports = stopcock;","map":null,"metadata":{},"sourceType":"script"}